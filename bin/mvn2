#!/usr/bin/env ruby

$LOAD_PATH << File.dirname(__FILE__)

require 'lib/maputil'
require 'lib/format'
require 'lib/kmeans'
require 'optparse'

include Format

options = {
    do_timer:           false,
    skip_tests:         false,
    no_sticky:          false,
    display_all:        false,
    track_average:      false,
    track_full_average: false,
    colored:            false,
    write_log:          false,
    log_file:           'build.log',
    advanced_average:   false,
    command_override: nil,
}

def add_option(options, opts, short_name, long_name, opt_name)
  opts.on(short_name, long_name) { options[opt_name] = true }
end

def add_option_with_param(options, opts, short_name, long_name, opt_name)
  opts.on(short_name, long_name) { |name| options[opt_name] = name }
end

option_parser = OptionParser.new { |opts|
  add_option(options, opts, '-t', '--timer', :do_timer)
  add_option(options, opts, '-s', '--skip-tests', :skip_tests)
  add_option(options, opts, '-n', '--no-sticky', :no_sticky)
  add_option(options, opts, '-a', '--display-all', :display_all)
  add_option(options, opts, '-k', '--track-average', :track_average)
  add_option(options, opts, '-u', '--track-full-average', :track_full_average)
  add_option(options, opts, '-c', '--colored', :colored)
  add_option(options, opts, '-l', '--write-log', :write_log)
  add_option_with_param(options, opts, '-f', '--log-file NAME', :log_file)
  add_option(options, opts, '-d', '--advanced-average', :advanced_average)
  add_option_with_param(options, opts, '-o', '--command-override', :command_override)
}

option_parser.parse!

Signal.trap('SIGINT') {
  puts "\nBuild Canceled\n\n"
  exit 1
}

st = options[:skip_tests] ? ' -D skipTests' : ''
cmd = options[:command_override].nil? ? "mvn clean install#{st} 2>&1" : "mvn #{options[:command_override]} 2>&1"

def full_avg_file(options)
  options[:skip_tests] ? 'avg-skip.txt' : 'avg-test.txt'
end

def read_full_avg(options, avg)
  average   = avg
  file_name = full_avg_file(options)
  if options[:command_override].nil? && options[:track_full_average] && File.exist?(file_name)
    lines   = IO.readlines(file_name)
    data    = lines.filtermap { |line|
      f = line.chomp
      f.length == 0 ? false : f.to_f
    }
    average = data.average
  end
  average
end

def read_advanced_avg(options, avg)
  averages  = [avg]
  file_name = full_avg_file(options)
  if options[:command_override].nil? && options[:track_full_average] && options[:advanced_average] && File.exist?(file_name)
    lines    = IO.readlines(file_name)
    data     = lines.filtermap { |line|
      f = line.chomp
      f.length == 0 ? false : f.to_f
    }
    averages = data.nmeans
  end
  averages
end

def update_full_avg(average, options, result, time1)
  if options[:command_override].nil? && options[:track_full_average] && (result || !options[:skip_tests])
    time2 = Time.now
    diff  = time2 - time1

    if result || diff >= average / 2.0
      file = File.new(full_avg_file(options), 'a+')
      file.puts(diff)
      file.close
    end
  end
end

def get_data(averages, counts, lines, ind)
  parts         = lines[ind].chomp.split(';')
  averages[ind] = parts[0].to_f
  counts[ind]   = parts[1].to_i
  averages[ind] = 0 if counts[ind] == 0
end

def read_avg(options)
  average  = 0
  averages = [0, 0]
  counts   = [0, 0]
  if options[:command_override].nil? && options[:track_average] && File.exist?('avg.txt')
    lines = IO.readlines('avg.txt')
    get_data(averages, counts, lines, 0)
    get_data(averages, counts, lines, 1)
    average = averages[options[:skip_tests] ? 0 : 1]
  end
  return average, averages, counts
end

def calc_new_avg(averages, counts, diff, ind)
  sum           = averages[ind] * counts[ind] + diff
  counts[ind]   += 1
  averages[ind] = sum / counts[ind]
end

def update_avg(average, averages, counts, options, result, time1)
  if options[:command_override].nil? && options[:track_average] && (result || !options[:skip_tests])
    time2 = Time.now
    diff  = time2 - time1

    if result || diff >= average / 2.0
      options[:skip_tests] ? calc_new_avg(averages, counts, diff, 0) : calc_new_avg(averages, counts, diff, 1)
      IO.write('avg.txt', "#{averages[0]};#{counts[0]}\n#{averages[1]};#{counts[1]}")
    end
  end
end

def colorize_if_should(text, fgcolor, colored)
  colored ? colorize(text, fgcolor) : text
end

def get_avg_message(amin, asec, avg, colored, diff, m, s)
  progress = ((diff.to_f / avg.to_f) * 100.0)
  bars     = [progress.floor, 100].min
  "[#{'=' * bars}>#{' ' * (100 - bars)}] #{colorize_if_should("#{m}:#{s}", :green, colored)} (#{colorize_if_should("~#{'%.3f' % progress}%", :purple, colored)}) (average: #{colorize_if_should("#{amin}:#{asec}", :cyan, colored)})"
end

def get_closest(averages, time)
  averages.min { |a, b| (a - time).abs <=> (b - time).abs}
end

def get_timer_message(avgs, colored, start_time, time)
  diff = time - start_time
  avg = get_closest(avgs, diff)
  amin, asec = get_time_parts(avg)
  m, s = get_time_parts(diff)
  (avg == 0) ? colorize_if_should("#{m}:#{s}", :green, colored) : get_avg_message(amin, asec, avg, colored, diff, m, s)
end

def get_time_parts(time)
  return (time / 60.0).floor, '%06.3f' % (time % 60)
end

def output_lines(output, options)
  IO.write(options[:log_file], output) if options[:write_log]
  lines = output.lines.chompall
  output.clear

  found = false

  lines.each { |line|
    if found
      puts line
    elsif line.start_with?('[ERROR] COMPILATION ERROR :') || line.start_with?('Results :')
      puts line
      found = true
    elsif line.start_with?('[INFO] BUILD SUCCESS') || line.start_with?('[INFO] Reactor Summary:')
      puts '[INFO] ------------------------------------------------------------------------'
      puts line
      found = true
    end }

  lines.each { |line| puts line } unless found
end

def start_timer_thread(averages, options, time1)
  Thread.new(time1, averages, options[:colored]) { |start_time, avgs, colored|
    while true
      print "\r#{get_timer_message(avgs, colored, start_time, Time.now)}"
      sleep(0.05)
    end
  }
end

def run_and_filter_output(options, cmd)
  average, averages, counts = read_avg(options)
  average                   = read_full_avg(options, average)
  averages2                 = read_advanced_avg(options, average)
  time1                     = Time.now
  thread                    = options[:do_timer] ? start_timer_thread(averages2, options, time1) : nil

  output = `#{cmd}`
  result = $?.success?

  update_avg(average, averages, counts, options, result, time1)
  update_full_avg(average, options, result, time1)

  unless thread.nil?
    thread.kill
    print "\n"
  end

  output_lines(output, options)
  result
end

result = options[:display_all] ? system(cmd) : run_and_filter_output(options, cmd)

`growlnotify -n Terminal -a Terminal#{(options[:no_sticky] ? '' : ' -s')} -m "#{(options[:command_override].nil? ? (options[:skip_tests] ? 'Build' : 'Tests') : 'Operation')} #{(result ? 'Successful' : 'Failed')}" -t "#{cmd[0...-5]}"`