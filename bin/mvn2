#!/usr/bin/env ruby

$LOAD_PATH << File.dirname(__FILE__)

require 'optparse'
require 'yaml'
require 'lib/maputil'
require 'lib/format'
require 'lib/kmeans'
require 'lib/option'

include Format

options = {
    do_timer:           false,
    skip_tests:         false,
    no_sticky:          false,
    display_all:        false,
    track_average:      false,
    track_full_average: false,
    colored:            false,
    write_log:          false,
    log_file:           'build.log',
    advanced_average:   false,
    command_override:   nil,
    package:            false,
    hide_between:       false,
    show_average:       false,
    block_update:       false,
    override_colors:    false,
}

option_parser = OptionParser.new { |opts|
  Option::add_option(options, opts, '-t', '--timer', :do_timer)
  Option::add_option(options, opts, '-s', '--skip-tests', :skip_tests)
  Option::add_option(options, opts, '-n', '--no-sticky', :no_sticky)
  Option::add_option(options, opts, '-a', '--display-all', :display_all)
  Option::add_option(options, opts, '-k', '--track-average', :track_average)
  Option::add_option(options, opts, '-u', '--track-full-average', :track_full_average)
  Option::add_option(options, opts, '-c', '--colored', :colored)
  Option::add_option(options, opts, '-l', '--write-log', :write_log)
  Option::add_option_with_param(options, opts, '-f', '--log-file NAME', :log_file)
  Option::add_option(options, opts, '-d', '--advanced-average', :advanced_average)
  Option::add_option_with_param(options, opts, '-o', '--command-override CMD', :command_override)
  Option::add_option(options, opts, '-p', '--package', :package)
  Option::add_option(options, opts, '-h', '--hide-between', :hide_between)
  Option::add_option(options, opts, '-w', '--show-average', :show_average)
  Option::add_option(options, opts, '-b', '--block-update', :block_update)
  Option::add_option(options, opts, '-v', '--override-colors', :override_colors)
}

option_parser.parse!

Signal.trap('SIGINT') {
  puts "\nBuild Canceled\n\n"
  exit 1
}

color_opts = {
    time:    {
        fg: :green,
        bg: :none,
    },
    percent: {
        fg: :purple,
        bg: :none,
    },
    average: {
        fg: :cyan,
        bg: :none,
    },
}

config_file = File.expand_path('~/mvn2-colors.yaml')

if options[:override_colors] && File.exist?(config_file)
  color_opts = YAML::load_file(config_file)
end

st   = options[:skip_tests] ? ' -D skipTests' : ''
cmd2 = options[:package] ? 'package' : 'install'
cmd  = options[:command_override].nil? ? "mvn clean #{cmd2}#{st} 2>&1" : "mvn #{options[:command_override]} 2>&1"

def full_avg_file(options)
  pkg = options[:package] ? '-package' : ''
  options[:skip_tests] ? "avg-skip#{pkg}.txt" : "avg-test#{pkg}.txt"
end

def read_full_avg(options, avg)
  average   = avg
  file_name = full_avg_file(options)
  if options[:command_override].nil? && options[:track_full_average] && File.exist?(file_name)
    lines   = IO.readlines(file_name)
    data    = lines.filtermap { |line|
      begin
        f = line.chomp
        f.length == 0 || (f =~ /^\d+(\.\d+)?$/).nil? ? false : f.to_f
      rescue
        false
      end
    }
    average = data.average
  end
  average
end

def read_advanced_avg(options, avg)
  averages  = [avg]
  file_name = full_avg_file(options)
  if options[:command_override].nil? && options[:track_full_average] && options[:advanced_average] && File.exist?(file_name)
    lines    = IO.readlines(file_name)
    data     = lines.filtermap { |line|
      begin
        f = line.chomp
        f.length == 0 || (f =~ /^\d+(\.\d+)?$/).nil? ? false : f.to_f
      rescue
        false
      end
    }
    averages = data.nmeans
  end
  averages
end

def update_full_avg(average, options, result, time1)
  unless options[:block_update]
    options[:command_override].nil? && options[:track_full_average] && (result || !options[:skip_tests])
    time2 = Time.now
    diff  = time2 - time1

    if result || diff >= average / 2.0
      file = File.new(full_avg_file(options), 'a+')
      file.puts(diff)
      file.close
    end
  end
end

def get_data(averages, counts, lines, ind)
  if lines.count > ind
    parts         = lines[ind].chomp.split(';')
    averages[ind] = parts[0].to_f
    counts[ind]   = parts[1].to_i
    averages[ind] = 0 if counts[ind] == 0
  end
end

def read_avg(options)
  average  = 0
  averages = [0, 0, 0, 0]
  counts   = [0, 0, 0, 0]
  if options[:command_override].nil? && options[:track_average] && File.exist?('avg.txt')
    lines = IO.readlines('avg.txt')
    get_data(averages, counts, lines, 0)
    get_data(averages, counts, lines, 1)
    get_data(averages, counts, lines, 2)
    get_data(averages, counts, lines, 3)
    pkg     = options[:package] ? 2 : 0
    average = averages[(options[:skip_tests] ? 0 : 1) + pkg]
  end
  return average, averages, counts
end

def calc_new_avg(averages, counts, diff, ind)
  sum           = averages[ind] * counts[ind] + diff
  counts[ind]   += 1
  averages[ind] = sum / counts[ind]
end

def update_avg(average, averages, counts, options, result, time1)
  unless options[:block_update]
    if options[:command_override].nil? && options[:track_average] && (result || !options[:skip_tests])
      time2 = Time.now
      diff  = time2 - time1

      if result || diff >= average / 2.0
        options[:skip_tests] ? calc_new_avg(averages, counts, diff, 0) : calc_new_avg(averages, counts, diff, 1)
        IO.write('avg.txt', "#{averages[0]};#{counts[0]}\n#{averages[1]};#{counts[1]}\n#{averages[2]};#{counts[2]}\n#{averages[3]};#{counts[3]}")
      end
    end
  end
end

def colorize_if_should(text, colors, colored)
  colored ? colorize(text, colors[:fg], colors[:bg]) : text
end

def get_avg_message(color_opts, amin, asec, avg, colored, diff, m, s)
  progress = ((diff.to_f / avg.to_f) * 100.0)
  bars     = [progress.floor, 100].min
  "[#{'=' * bars}>#{' ' * (100 - bars)}] #{colorize_if_should("#{m}:#{s}", color_opts[:time], colored)} (#{colorize_if_should("~#{'%.3f' % progress}%", color_opts[:percent], colored)}) (average: #{colorize_if_should("#{amin}:#{asec}", color_opts[:average], colored)})"
end

def get_closest(averages, time)
  averages.min { |a, b| (a - time).abs <=> (b - time).abs }
end

def get_timer_message(color_opts, avgs, colored, start_time, time)
  diff       = time - start_time
  avg        = get_closest(avgs, diff)
  amin, asec = get_time_parts(avg)
  m, s       = get_time_parts(diff)
  (avg == 0) ? colorize_if_should("#{m}:#{s}", color_opts[:time], colored) : get_avg_message(color_opts, amin, asec, avg, colored, diff, m, s)
end

def get_time_parts(time)
  return (time / 60.0).floor, '%06.3f' % (time % 60)
end

def output_lines(output, options)
  IO.write(options[:log_file], output) if options[:write_log]
  lines = output.lines.chompall
  output.clear

  found = false

  lines.each { |line|
    if options[:hide_between] && found && line.start_with?('Tests run:')
      puts "#{line}\n\n"
      found = false
    elsif found
      puts line
    elsif line.start_with?('[ERROR] COMPILATION ERROR :') || line.start_with?('Results :')
      puts line
      found = true
    elsif line.start_with?('[INFO] BUILD SUCCESS') || line.start_with?('[INFO] Reactor Summary:') || line.start_with?('[INFO] BUILD FAILURE')
      puts '[INFO] ------------------------------------------------------------------------'
      puts line
      found = true
    end }

  lines.each { |line| puts line } unless found
end

def start_timer_thread(color_opts, averages, options, time1)
  Thread.new(time1, averages, options[:colored], color_opts) { |start_time, avgs, colored, color_opts|
    while true
      print "\r#{get_timer_message(color_opts, avgs, colored, start_time, Time.now)}"
      sleep(0.05)
    end
  }
end

def show_averages(averages2)
  unless averages2.empty? || (averages2.length == 1 && averages2[0] == 0)
    strs = averages2.map { |a|
      m, s = get_time_parts(a);
      "#{m}:#{s}"
    }
    puts "Average(s): #{strs.join(', ')}"
  end
end

def run_and_filter_output(color_opts, options, cmd)
  average, averages, counts = read_avg(options)
  average                   = read_full_avg(options, average)
  averages2                 = read_advanced_avg(options, average)
  show_averages(averages2) if options[:show_average]
  time1  = Time.now
  thread = options[:do_timer] ? start_timer_thread(color_opts, averages2, options, time1) : nil

  output = `#{cmd}`
  result = $?.success?

  update_avg(average, averages, counts, options, result, time1)
  update_full_avg(average, options, result, time1)

  unless thread.nil?
    thread.kill
    print "\n"
  end

  if options[:show_average]
    average, averages, counts = read_avg(options)
    average                   = read_full_avg(options, average)
    averages2                 = read_advanced_avg(options, average)
    show_averages(averages2)
  end

  output_lines(output, options)
  result
end

result = options[:display_all] ? system(cmd) : run_and_filter_output(color_opts, options, cmd)

`growlnotify -n Terminal -a Terminal#{(options[:no_sticky] ? '' : ' -s')} -m "#{(options[:command_override].nil? ? (options[:skip_tests] ? 'Build' : 'Tests') : 'Operation')} #{(result ? 'Successful' : 'Failed')}" -t "#{cmd[0...-5]}"`