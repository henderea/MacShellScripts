#!/usr/bin/env ruby

$LOAD_PATH << File.dirname(__FILE__)

require 'optparse'
require 'yaml'
require 'net/http'
require 'lib/maputil'
require 'lib/format'
require 'lib/kmeans'
require 'lib/option'

WEB_DOMAIN = 'enigmatic-bayou-2042.herokuapp.com'
BASE_PATH  = '/mvn2/'

options = {
    do_timer:           false,
    skip_tests:         false,
    no_sticky:          false,
    display_all:        false,
    track_average:      false,
    track_full_average: false,
    colored:            false,
    write_log:          false,
    log_file:           'build.log',
    advanced_average:   false,
    command_override:   nil,
    package:            false,
    hide_between:       false,
    show_average:       false,
    block_update:       false,
    override_colors:    false,
    show_projects:      false,
    run_before:         nil,
    run_after:          nil,
    run_success:        nil,
    run_failure:        nil,
    low_mem:            false,
    exception:          false,
    live_print:         false,
    mobile_number:      nil,
    advanced_text:      false,
}

if File.exist?('mvn2-defaults.yaml')
  options = YAML::load_file('mvn2-defaults.yaml')
end

set_defaults  = false
#abcd   h jklmn p  stuvw   01
#    efg i     o qr     xyz  23456789
option_parser = OptionParser.new { |opts|
  Option::add_option(options, opts, '-t', '--timer', :do_timer)
  Option::add_option(options, opts, '-s', '--skip-tests', :skip_tests)
  Option::add_option(options, opts, '-n', '--no-sticky', :no_sticky)
  Option::add_option(options, opts, '-a', '--display-all', :display_all)
  Option::add_option(options, opts, '-k', '--track-average', :track_average)
  Option::add_option(options, opts, '-u', '--track-full-average', :track_full_average)
  Option::add_option(options, opts, '-c', '--colored', :colored)
  Option::add_option(options, opts, '-l', '--write-log', :write_log)
  Option::add_option_with_param_single(options, opts, '--log-file NAME', :log_file)
  Option::add_option(options, opts, '-d', '--advanced-average', :advanced_average)
  Option::add_option_with_param_single(options, opts, '--command-override CMD', :command_override)
  Option::add_option(options, opts, '-p', '--package', :package)
  Option::add_option(options, opts, '-h', '--hide-between', :hide_between)
  Option::add_option(options, opts, '-w', '--show-average', :show_average)
  Option::add_option(options, opts, '-b', '--block-update', :block_update)
  Option::add_option(options, opts, '-v', '--override-colors', :override_colors)
  Option::add_option(options, opts, '-j', '--show-projects', :show_projects)
  Option::add_option_with_param_single(options, opts, '--run-before CMD', :run_before)
  Option::add_option_with_param_single(options, opts, '--run-after CMD', :run_after)
  Option::add_option_with_param_single(options, opts, '--run-success CMD', :run_success)
  Option::add_option_with_param_single(options, opts, '--run-failure CMD', :run_failure)
  Option::add_option(options, opts, '-m', '--low-mem', :low_mem)
  Option::add_option(options, opts, '-e', '--exception', :exception)
  Option::add_option(options, opts, '-0', '--live-print', :live_print)
  Option::add_option_with_param_single(options, opts, '--mobile-number NUM', :mobile_number)
  Option::add_option(options, opts, '-2', '--advanced-text', :advanced_text)
  opts.on('-1', '--set-defaults') { set_defaults = true }
}

option_parser.parse!

if set_defaults
  IO.write('mvn2-defaults.yaml', options.to_yaml)
  puts 'Defaults set'
  exit 0
end

Signal.trap('SIGINT') {
  puts "\nBuild Canceled\n\n"
  exit 1
}

class String
  def start_with_any?(*strs)
    strs.empty? ? false : strs.any? { |str| start_with?(str) }
  end
end

color_opts = {
    time:    {
        fg: :green,
        bg: :none,
    },
    percent: {
        fg: :purple,
        bg: :none,
    },
    average: {
        fg: :cyan,
        bg: :none,
    },
}

config_file = File.expand_path('~/mvn2-colors.yaml')

if options[:override_colors] && File.exist?(config_file)
  color_opts = YAML::load_file(config_file)
end

def read_page(path)
  begin
    return Net::HTTP.get(WEB_DOMAIN, "#{BASE_PATH}#{path}")
  rescue
    # ignored
  end
  nil
end

class Mvn2
  HEADLESS = ' -Djava.awt.headless=true'

  def initialize(options, color_opts)
    @options    = options
    @color_opts = color_opts
    st          = @options[:skip_tests] ? ' -D skipTests' : ''
    cmd2        = @options[:package] ? 'package' : 'install'
    exc         = @options[:exception] ? ' -e -X' : ''
    @cmd        = @options[:command_override].nil? ? "mvn clean #{cmd2}#{st}#{exc}#{HEADLESS} 2>&1" : "mvn #{options[:command_override]}#{exc}#{HEADLESS} 2>&1"
  end

  def full_avg_file
    pkg = @options[:package] ? '-package' : ''
    @options[:skip_tests] ? "avg-skip#{pkg}.txt" : "avg-test#{pkg}.txt"
  end

  def read_full_avg
    average   = @average
    file_name = full_avg_file
    if @options[:command_override].nil? && @options[:track_full_average] && File.exist?(file_name)
      lines   = IO.readlines(file_name)
      data    = lines.filtermap { |line|
        begin
          f = line.chomp
          f.length == 0 || (f =~ /^\d+(\.\d+)?$/).nil? ? false : f.to_f
        rescue
          false
        end
      }
      average = data.average
    end
    average
  end

  def read_advanced_avg
    averages  = [@average]
    file_name = full_avg_file
    if @options[:command_override].nil? && @options[:track_full_average] && @options[:advanced_average] && File.exist?(file_name)
      lines    = IO.readlines(file_name)
      data     = lines.filtermap { |line|
        begin
          f = line.chomp
          f.length == 0 || (f =~ /^\d+(\.\d+)?$/).nil? ? false : f.to_f
        rescue
          false
        end
      }
      averages = data.nmeans
    end
    averages
  end

  def update_full_avg
    unless @options[:block_update]
      @options[:command_override].nil? && @options[:track_full_average] && (@result || !@options[:skip_tests])

      if @result || (!options[:skip_tests] && @diff >= @average / 2.0)
        file = File.new(full_avg_file, 'a+')
        file.puts(@diff)
        file.close
      end
    end
  end

  def get_data(averages, counts, lines, ind)
    if lines.count > ind
      parts         = lines[ind].chomp.split(';')
      averages[ind] = parts[0].to_f
      counts[ind]   = parts[1].to_i
      averages[ind] = 0 if counts[ind] == 0
    end
  end

  def read_avg
    average  = 0
    averages = [0, 0, 0, 0]
    counts   = [0, 0, 0, 0]
    if @options[:command_override].nil? && @options[:track_average] && File.exist?('avg.txt')
      lines = IO.readlines('avg.txt')
      get_data(averages, counts, lines, 0)
      get_data(averages, counts, lines, 1)
      get_data(averages, counts, lines, 2)
      get_data(averages, counts, lines, 3)
      pkg     = @options[:package] ? 2 : 0
      average = averages[(@options[:skip_tests] ? 0 : 1) + pkg]
    end
    return average, averages, counts
  end

  def calc_new_avg(ind)
    sum             = @averages2[ind] * @counts[ind] + @diff
    @counts[ind]    += 1
    @averages2[ind] = sum / @counts[ind]
  end

  def update_avg
    unless @options[:block_update]
      if @options[:command_override].nil? && @options[:track_average] && (@result || !@options[:skip_tests])

        if @result || @diff >= @average / 2.0
          @options[:skip_tests] ? calc_new_avg(0) : calc_new_avg(1)
          IO.write('avg.txt', "#{@averages2[0]};#{@counts[0]}\n#{@averages2[1]};#{@counts[1]}\n#{@averages2[2]};#{@counts[2]}\n#{@averages2[3]};#{@counts[3]}")
        end
      end
    end
  end

  def colorize_if_should(text, colors)
    @options[:colored] ? Format::colorize(text, colors[:fg], colors[:bg]) : text
  end

  def get_avg_message(amin, asec, avg, diff, m, s)
    progress = ((diff.to_f / avg.to_f) * 100.0)
    bars     = [progress.floor, 100].min
    "[#{'=' * bars}>#{' ' * (100 - bars)}] #{colorize_if_should("#{m}:#{s}", @color_opts[:time])} (#{colorize_if_should("~#{'%.3f' % progress}%", @color_opts[:percent])}) (average: #{colorize_if_should("#{amin}:#{asec}", @color_opts[:average])})"
  end

  def get_closest(time)
    @averages.min { |a, b| (a - time).abs <=> (b - time).abs }
  end

  def get_timer_message(start_time, time)
    diff       = time - start_time
    avg        = get_closest(diff)
    amin, asec = get_time_parts(avg)
    m, s       = get_time_parts(diff)
    (avg == 0) ? colorize_if_should("#{m}:#{s}", @color_opts[:time]) : get_avg_message(amin, asec, avg, diff, m, s)
  end

  def get_time_parts(time)
    return (time / 60.0).floor, '%06.3f' % (time % 60)
  end

  INFO_LINE   = '[INFO] ------------------------------------------------------------------------'
  BUILD_REGEX = /\[INFO\] Building (?!(jar|war|zip))/

  def filter_line(found, info_line_last, l, puts_prefix = '')
    line = l.chomp
    begin
      if @options[:show_projects] && line =~ BUILD_REGEX
        puts "#{puts_prefix}#{INFO_LINE}" unless info_line_last
        puts "#{puts_prefix}#{line}"
        puts "#{puts_prefix}#{INFO_LINE}"
        info_line_last = true
      elsif @options[:hide_between] && found && line.start_with?('Tests run:')
        puts "#{puts_prefix}#{line}\n\n"
        found          = false
        info_line_last = false
      elsif found
        puts "#{puts_prefix}#{line}"
        info_line_last = line.start_with?(INFO_LINE)
      elsif line.start_with_any?('[ERROR] COMPILATION ERROR :', 'Results :')
        puts "#{puts_prefix}#{line}"
        found          = true
        info_line_last = false
      elsif line.start_with_any?('[INFO] BUILD SUCCESS', '[INFO] Reactor Summary:', '[INFO] BUILD FAILURE')
        puts "#{puts_prefix}#{INFO_LINE}" unless info_line_last
        puts "#{puts_prefix}#{line}"
        found          = true
        info_line_last = false
      end
    rescue
      puts "#{puts_prefix}#{line}"
    end
    return found, info_line_last
  end

  def output_lines
    IO.write(@options[:log_file], @output) if @options[:write_log]
    found          = false
    info_line_last = false
    if @options[:low_mem]
      @output.each_line { |l|
        found, info_line_last = filter_line(found, info_line_last, l, @options)
      }

      @output.each_line { |line| puts line } unless found
    else
      lines = @output.lines.chompall
      @output.clear

      lines.each { |l|
        found, info_line_last = filter_line(found, info_line_last, l, @options)
      }

      lines.each { |line| puts line } unless found
    end
  end

  def start_timer_thread
    Thread.new(@time1) { |start_time|
      while true
        print "\r#{get_timer_message(start_time, Time.now)}"
        sleep(0.05)
      end
    }
  end

  def start_timer_thread2
    Thread.new(@time1) { |start_time|
      begin
        path = Dir.getwd
        path = path[(path.rindex('/')+1)..-1]
        id  = read_page("create?phone=#{@options[:mobile_number]}&name=#{path}")
        while true
          sleep(2.5)
          diff     = Time.now - start_time
          avg      = get_closest(diff)
          progress = (diff / avg) * 100.0
          read_page("update?id=#{id}&time=#{diff}&progress=#{progress}")
        end
      ensure
        read_page("remove?id=#{id}")
      end
    }
  end

  def show_averages
    unless @averages.empty? || (@averages.length == 1 && @averages[0] == 0)
      strs = @averages.map { |a|
        m, s = get_time_parts(a)
        "#{m}:#{s}"
      }
      puts "Average(s): #{strs.join(', ')}"
    end
  end

  def run_and_filter_output
    @average, @averages2, @counts = read_avg
    @average                      = read_full_avg
    @averages                     = read_advanced_avg
    show_averages if @options[:show_average]
    @time1 = Time.now
    thread = @options[:do_timer] ? start_timer_thread : nil
    thread2 = @options[:advanced_text] ? start_timer_thread2 : nil

    if @options[:live_print]
      found          = false
      info_line_last = false
      @result        = false
      begin
        log_file = @options[:write_log] ? File.open(@options[:log_file], 'w+') : nil
        IO.popen(@cmd).each do |l|
          log_file << l unless log_file.nil?
          found, info_line_last = filter_line(found, info_line_last, l, "\r\e[2K")
          @result               = true if l.chomp.start_with?('[INFO] BUILD SUCCESS')
        end
      ensure
        log_file.close unless log_file.nil?
      end
    else
      @output = `#{@cmd}`
      @result = $?.success?
    end

    time2 = Time.now
    @diff = time2 - @time1

    update_avg
    update_full_avg

    unless thread.nil?
      thread.kill
      print "\n"
    end

    unless thread2.nil?
      thread2.kill
      print "\n"
    end

    if @options[:show_average]
      @average, _, _ = read_avg
      @average       = read_full_avg
      @averages      = read_advanced_avg
      show_averages
    end

    output_lines unless @options[:live_print]
  end

  def run_cmd(cmd)
    unless cmd.nil?
      puts "$ #{cmd}"
      `#{cmd}`
      print "\n"
    end
  end

  def run
    run_cmd(@options[:run_before])
    @options[:display_all] ? system(@cmd) : run_and_filter_output
    run_cmd(@options[:run_after])
    if @result
      run_cmd(@options[:run_success])
    else
      run_cmd(@options[:run_failure])
    end

    message_text  = "#{(@options[:command_override].nil? ? (@options[:skip_tests] ? 'Build' : 'Tests') : 'Operation')} #{(@result ? 'Successful' : 'Failed')}"
    message_title = @cmd[0...(-5-HEADLESS.length)]

    unless @options[:mobile_number].nil?
      begin
        require 'nexmo'
      rescue LoadError
        puts 'You need to run \'gem install nexmo\' to use this feature'
        exit 1
      end
      path = Dir.getwd

      path = path[(path.rindex('/')+1)..-1]

      sms_message = "#{path}: #{message_text}"

      nexmo = Nexmo::Client.new('8c3b6e7d', 'a1d2ac24')

      nexmo.send_message!({ :to => @options[:mobile_number], :from => '13179120742', :text => sms_message })
    end

    begin
      `growlnotify -n Terminal -a Terminal#{(@options[:no_sticky] ? '' : ' -s')} -m "#{message_text}" -t "#{message_title}" 2>&1`
    end until $?.success?
  end
end

Mvn2.new(options, color_opts).run