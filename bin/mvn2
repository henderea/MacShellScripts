#!/usr/bin/env ruby

$LOAD_PATH << File.dirname(__FILE__)

require 'optparse'
require 'yaml'
require 'lib/maputil'
require 'lib/format'
require 'lib/kmeans'
require 'lib/option'

options       = {
    do_timer:           false,
    skip_tests:         false,
    no_sticky:          false,
    display_all:        false,
    track_average:      false,
    track_full_average: false,
    colored:            false,
    write_log:          false,
    log_file:           'build.log',
    advanced_average:   false,
    command_override:   nil,
    package:            false,
    hide_between:       false,
    show_average:       false,
    block_update:       false,
    override_colors:    false,
    show_projects:      false,
    run_before:         nil,
    run_after:          nil,
    run_success:        nil,
    run_failure:        nil,
    low_mem:            false,
    exception:          false,
    live_print:         false,
}
#abcd   h jklmn p  stuvw   0
#    efg i     o qr     xyz 123456789
option_parser = OptionParser.new { |opts|
  Option::add_option(options, opts, '-t', '--timer', :do_timer)
  Option::add_option(options, opts, '-s', '--skip-tests', :skip_tests)
  Option::add_option(options, opts, '-n', '--no-sticky', :no_sticky)
  Option::add_option(options, opts, '-a', '--display-all', :display_all)
  Option::add_option(options, opts, '-k', '--track-average', :track_average)
  Option::add_option(options, opts, '-u', '--track-full-average', :track_full_average)
  Option::add_option(options, opts, '-c', '--colored', :colored)
  Option::add_option(options, opts, '-l', '--write-log', :write_log)
  Option::add_option_with_param_single(options, opts, '--log-file NAME', :log_file)
  Option::add_option(options, opts, '-d', '--advanced-average', :advanced_average)
  Option::add_option_with_param_single(options, opts, '--command-override CMD', :command_override)
  Option::add_option(options, opts, '-p', '--package', :package)
  Option::add_option(options, opts, '-h', '--hide-between', :hide_between)
  Option::add_option(options, opts, '-w', '--show-average', :show_average)
  Option::add_option(options, opts, '-b', '--block-update', :block_update)
  Option::add_option(options, opts, '-v', '--override-colors', :override_colors)
  Option::add_option(options, opts, '-j', '--show-projects', :show_projects)
  Option::add_option_with_param_single(options, opts, '--run-before CMD', :run_before)
  Option::add_option_with_param_single(options, opts, '--run-after CMD', :run_after)
  Option::add_option_with_param_single(options, opts, '--run-success CMD', :run_success)
  Option::add_option_with_param_single(options, opts, '--run-failure CMD', :run_failure)
  Option::add_option(options, opts, '-m', '--low-mem', :low_mem)
  Option::add_option(options, opts, '-e', '--exception', :exception)
  Option::add_option(options, opts, '-0', '--live-print', :live_print)
}

option_parser.parse!

Signal.trap('SIGINT') {
  puts "\nBuild Canceled\n\n"
  exit 1
}

class String
  def start_with_any?(*strs)
    strs.empty? ? false : strs.any? { |str| start_with?(str) }
  end
end

color_opts = {
    time:    {
        fg: :green,
        bg: :none,
    },
    percent: {
        fg: :purple,
        bg: :none,
    },
    average: {
        fg: :cyan,
        bg: :none,
    },
}

config_file = File.expand_path('~/mvn2-colors.yaml')

if options[:override_colors] && File.exist?(config_file)
  color_opts = YAML::load_file(config_file)
end

st       = options[:skip_tests] ? ' -D skipTests' : ''
cmd2     = options[:package] ? 'package' : 'install'
exc      = options[:exception] ? ' -e -X' : ''
headless = ' -Djava.awt.headless=true'
cmd      = options[:command_override].nil? ? "mvn clean #{cmd2}#{st}#{exc}#{headless} 2>&1" : "mvn #{options[:command_override]}#{exc}#{headless} 2>&1"

def full_avg_file(options)
  pkg = options[:package] ? '-package' : ''
  options[:skip_tests] ? "avg-skip#{pkg}.txt" : "avg-test#{pkg}.txt"
end

def read_full_avg(options, avg)
  average   = avg
  file_name = full_avg_file(options)
  if options[:command_override].nil? && options[:track_full_average] && File.exist?(file_name)
    lines   = IO.readlines(file_name)
    data    = lines.filtermap { |line|
      begin
        f = line.chomp
        f.length == 0 || (f =~ /^\d+(\.\d+)?$/).nil? ? false : f.to_f
      rescue
        false
      end
    }
    average = data.average
  end
  average
end

def read_advanced_avg(options, avg)
  averages  = [avg]
  file_name = full_avg_file(options)
  if options[:command_override].nil? && options[:track_full_average] && options[:advanced_average] && File.exist?(file_name)
    lines    = IO.readlines(file_name)
    data     = lines.filtermap { |line|
      begin
        f = line.chomp
        f.length == 0 || (f =~ /^\d+(\.\d+)?$/).nil? ? false : f.to_f
      rescue
        false
      end
    }
    averages = data.nmeans
  end
  averages
end

def update_full_avg(average, options, result, time1)
  unless options[:block_update]
    options[:command_override].nil? && options[:track_full_average] && (result || !options[:skip_tests])
    time2 = Time.now
    diff  = time2 - time1

    if result || (!options[:skip_tests] && diff >= average / 2.0)
      file = File.new(full_avg_file(options), 'a+')
      file.puts(diff)
      file.close
    end
  end
end

def get_data(averages, counts, lines, ind)
  if lines.count > ind
    parts         = lines[ind].chomp.split(';')
    averages[ind] = parts[0].to_f
    counts[ind]   = parts[1].to_i
    averages[ind] = 0 if counts[ind] == 0
  end
end

def read_avg(options)
  average  = 0
  averages = [0, 0, 0, 0]
  counts   = [0, 0, 0, 0]
  if options[:command_override].nil? && options[:track_average] && File.exist?('avg.txt')
    lines = IO.readlines('avg.txt')
    get_data(averages, counts, lines, 0)
    get_data(averages, counts, lines, 1)
    get_data(averages, counts, lines, 2)
    get_data(averages, counts, lines, 3)
    pkg     = options[:package] ? 2 : 0
    average = averages[(options[:skip_tests] ? 0 : 1) + pkg]
  end
  return average, averages, counts
end

def calc_new_avg(averages, counts, diff, ind)
  sum           = averages[ind] * counts[ind] + diff
  counts[ind]   += 1
  averages[ind] = sum / counts[ind]
end

def update_avg(average, averages, counts, options, result, time1)
  unless options[:block_update]
    if options[:command_override].nil? && options[:track_average] && (result || !options[:skip_tests])
      time2 = Time.now
      diff  = time2 - time1

      if result || diff >= average / 2.0
        options[:skip_tests] ? calc_new_avg(averages, counts, diff, 0) : calc_new_avg(averages, counts, diff, 1)
        IO.write('avg.txt', "#{averages[0]};#{counts[0]}\n#{averages[1]};#{counts[1]}\n#{averages[2]};#{counts[2]}\n#{averages[3]};#{counts[3]}")
      end
    end
  end
end

def colorize_if_should(text, colors, colored)
  colored ? Format::colorize(text, colors[:fg], colors[:bg]) : text
end

def get_avg_message(color_opts, amin, asec, avg, colored, diff, m, s)
  progress = ((diff.to_f / avg.to_f) * 100.0)
  bars     = [progress.floor, 100].min
  "[#{'=' * bars}>#{' ' * (100 - bars)}] #{colorize_if_should("#{m}:#{s}", color_opts[:time], colored)} (#{colorize_if_should("~#{'%.3f' % progress}%", color_opts[:percent], colored)}) (average: #{colorize_if_should("#{amin}:#{asec}", color_opts[:average], colored)})"
end

def get_closest(averages, time)
  averages.min { |a, b| (a - time).abs <=> (b - time).abs }
end

def get_timer_message(color_opts, avgs, colored, start_time, time)
  diff       = time - start_time
  avg        = get_closest(avgs, diff)
  amin, asec = get_time_parts(avg)
  m, s       = get_time_parts(diff)
  (avg == 0) ? colorize_if_should("#{m}:#{s}", color_opts[:time], colored) : get_avg_message(color_opts, amin, asec, avg, colored, diff, m, s)
end

def get_time_parts(time)
  return (time / 60.0).floor, '%06.3f' % (time % 60)
end

INFO_LINE   = '[INFO] ------------------------------------------------------------------------'
BUILD_REGEX = /\[INFO\] Building (?!(jar|war|zip))/

def filter_line(found, info_line_last, l, options, puts_prefix = '')
  line = l.chomp
  begin
    if options[:show_projects] && line =~ BUILD_REGEX
      puts "#{puts_prefix}#{INFO_LINE}" unless info_line_last
      puts "#{puts_prefix}#{line}"
      puts "#{puts_prefix}#{INFO_LINE}"
      info_line_last = true
    elsif options[:hide_between] && found && line.start_with?('Tests run:')
      puts "#{puts_prefix}#{line}\n\n"
      found          = false
      info_line_last = false
    elsif found
      puts "#{puts_prefix}#{line}"
      info_line_last = line.start_with?(INFO_LINE)
    elsif line.start_with_any?('[ERROR] COMPILATION ERROR :', 'Results :')
      puts "#{puts_prefix}#{line}"
      found          = true
      info_line_last = false
    elsif line.start_with_any?('[INFO] BUILD SUCCESS', '[INFO] Reactor Summary:', '[INFO] BUILD FAILURE')
      puts "#{puts_prefix}#{INFO_LINE}" unless info_line_last
      puts "#{puts_prefix}#{line}"
      found          = true
      info_line_last = false
    end
  rescue
    puts "#{puts_prefix}#{line}"
  end
  return found, info_line_last
end

def output_lines(output, options)
  IO.write(options[:log_file], output) if options[:write_log]
  found          = false
  info_line_last = false
  if options[:low_mem]
    output.each_line { |l|
      found, info_line_last = filter_line(found, info_line_last, l, options)
    }

    output.each_line { |line| puts line } unless found
  else
    lines = output.lines.chompall
    output.clear

    lines.each { |l|
      found, info_line_last = filter_line(found, info_line_last, l, options)
    }

    lines.each { |line| puts line } unless found
  end
end

def start_timer_thread(color_opts, averages, options, time1)
  Thread.new(time1, averages, options[:colored], color_opts) { |start_time, avgs, colored, colors|
    while true
      print "\r#{get_timer_message(colors, avgs, colored, start_time, Time.now)}"
      sleep(0.05)
    end
  }
end

def show_averages(averages2)
  unless averages2.empty? || (averages2.length == 1 && averages2[0] == 0)
    strs = averages2.map { |a|
      m, s = get_time_parts(a)
      "#{m}:#{s}"
    }
    puts "Average(s): #{strs.join(', ')}"
  end
end

def run_and_filter_output(color_opts, options, cmd)
  average, averages, counts = read_avg(options)
  average                   = read_full_avg(options, average)
  averages2                 = read_advanced_avg(options, average)
  show_averages(averages2) if options[:show_average]
  time1  = Time.now
  thread = options[:do_timer] ? start_timer_thread(color_opts, averages2, options, time1) : nil

  if options[:live_print]
    found          = false
    info_line_last = false
    result         = false
    begin
      log_file = options[:write_log] ? File.open(options[:log_file], 'w+') : nil
      IO.popen(cmd).each do |l|
        log_file << l unless log_file.nil?
        found, info_line_last = filter_line(found, info_line_last, l, options, "\r\e[2K")
        result                = true if l.chomp.start_with?('[INFO] BUILD SUCCESS')
      end
    ensure
      log_file.close unless log_file.nil?
    end
  else
    output = `#{cmd}`
    result = $?.success?
  end

  update_avg(average, averages, counts, options, result, time1)
  update_full_avg(average, options, result, time1)

  unless thread.nil?
    thread.kill
    print "\n"
  end

  if options[:show_average]
    average, _, _ = read_avg(options)
    average       = read_full_avg(options, average)
    averages2     = read_advanced_avg(options, average)
    show_averages(averages2)
  end

  output_lines(output, options) unless options[:live_print]
  result
end

def run_cmd(cmd)
  unless cmd.nil?
    puts "$ #{cmd}"
    `#{cmd}`
    print "\n"
  end
end

run_cmd(options[:run_before])
result = options[:display_all] ? system(cmd) : run_and_filter_output(color_opts, options, cmd)
run_cmd(options[:run_after])
if result
  run_cmd(options[:run_success])
else
  run_cmd(options[:run_failure])
end

begin
  `growlnotify -n Terminal -a Terminal#{(options[:no_sticky] ? '' : ' -s')} -m "#{(options[:command_override].nil? ? (options[:skip_tests] ? 'Build' : 'Tests') : 'Operation')} #{(result ? 'Successful' : 'Failed')}" -t "#{cmd[0...(-5-headless.length)]}" 2>&1`
end until $?.success?