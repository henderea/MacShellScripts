#!/usr/bin/env ruby

$LOAD_PATH << File.dirname(__FILE__)

require 'lib/format'
require 'optparse'

include Format

options = {
    do_timer: false,
    skip_tests: false,
    no_sticky: false,
    display_all: false,
    track_average: false,
    colored: false,
}

def add_option(options, opts, short_name, long_name, opt_name)
  opts.on(short_name, long_name) do
    options[opt_name] = true
  end
end

option_parser = OptionParser.new do |opts|
  add_option(options, opts, '-t', '--timer', :do_timer)
  add_option(options, opts, '-s', '--skip-tests', :skip_tests)
  add_option(options, opts, '-n', '--no-sticky', :no_sticky)
  add_option(options, opts, '-a', '--display-all', :display_all)
  add_option(options, opts, '-k', '--track-average', :track_average)
  add_option(options, opts, '-c', '--colored', :colored)
end

option_parser.parse!

Signal.trap('SIGINT') do
  puts "\nBuild Canceled\n\n"
  exit 1
end

st = options[:skip_tests] ? ' -D skipTests' : ''

def get_data(averages, counts, lines, ind)
  parts = lines[ind].chomp.split(';')
  averages[ind] = parts[0].to_i
  counts[ind] = parts[1].to_i
  averages[ind] = 0 if counts[ind] == 0
end

def read_avg(options)
  average = 0
  averages = [0, 0]
  counts = [0, 0]
  if options[:track_average] && File.exist?('avg.txt')
    lines = IO.readlines('avg.txt')
    get_data(averages, counts, lines, 0)
    get_data(averages, counts, lines, 1)
    average = averages[options[:skip_tests] ? 0 : 1]
  end
  return average, averages, counts
end

def calc_new_avg(averages, counts, diff, ind)
  sum = averages[ind] * counts[ind] + diff
  counts[ind] += 1
  averages[ind] = sum / counts[ind]
end

def update_avg(average, averages, counts, options, result, time1)
  if options[:track_average] && (result || !options[:skip_tests])
    time2 = Time.now
    diff = time2 - time1

    if result || diff >= average / 2.0
      options[:skip_tests] ? calc_new_avg(averages, counts, diff, 0) : calc_new_avg(averages, counts, diff, 1)
      IO.write('avg.txt', "#{averages[0]};#{counts[0]}\n#{averages[1]};#{counts[1]}")
    end
  end
end

def colorize_if_should(text, fgcolor, colored)
  colored ? colorize(text, fgcolor) : text
end

def get_avg_message(amin, asec, avg, colored, diff, m, s)
  progress = ((diff.to_f / avg.to_f) * 100.0)
  bars = [progress.floor, 100].min
  "[#{'=' * bars}>#{' ' * (100 - bars)}] #{colorize_if_should("#{m}:#{s}", :green, colored)} (#{colorize_if_should("~#{'%.3f' % progress}%", :purple, colored)}) (average: #{colorize_if_should("#{amin}:#{asec}", :cyan, colored)})"
end

def get_timer_message(amin, asec, avg, colored, start_time, time)
  diff = time - start_time
  m, s = get_time_parts(diff)
  (avg == 0) ? colorize_if_should("#{m}:#{s}", :green, colored) : get_avg_message(amin, asec, avg, colored, diff, m, s)
end

def get_time_parts(time)
  return (time / 60.0).floor, '%06.3f' % (time % 60)
end

def output_lines(output)
  lines = output.lines.map(&:chomp)
  output.clear

  found = false

  lines.each do |line|
    if found
      puts line
    elsif line.start_with?('[ERROR] COMPILATION ERROR :') || line.start_with?('Results :')
      puts line
      found = true
    elsif line.start_with?('[INFO] BUILD SUCCESS') || line.start_with?('[INFO] Reactor Summary:')
      puts '[INFO] ------------------------------------------------------------------------'
      puts line
      found = true
    end
  end

  unless found
    lines.each do |line|
      puts line
    end
  end
end

def run_and_filter_output(options, st)
  thread = nil
  average, averages, counts = read_avg(options)
  time1 = Time.now
  if options[:do_timer]
    thread = Thread.new(time1, average, options[:colored]) do |start_time, avg, colored|
      amin, asec = get_time_parts(avg)
      while true
        print "\r#{get_timer_message(amin, asec, avg, colored, start_time, Time.now)}"
        sleep(0.05)
      end
    end
  end

  output = `mvn clean install#{st} 2>&1`
  result = $?.success?

  update_avg(average, averages, counts, options, result, time1)

  unless thread.nil?
    thread.kill
    print "\n"
  end

  output_lines(output)
  result
end

result = options[:display_all] ? system("mvn clean install#{st} 2>&1") : run_and_filter_output(options, st)

`growlnotify -n Terminal -a Terminal#{(options[:no_sticky] ? '' : ' -s')} -m "#{(options[:skip_tests] ? 'Build' : 'Tests')} #{(result ? 'Successful' : 'Failed')}" -t "mvn clean install#{st}"`