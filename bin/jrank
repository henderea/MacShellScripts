#!/usr/bin/env ruby

$LOAD_PATH << File.dirname(__FILE__)

require 'optparse'
require 'net/http'
require 'yaml'
require 'curses'
require 'lib/maputil'
require 'lib/option'
require 'lib/format'

options = {
    adjust_scores:    false,
    show_both:        false,
    update:           false,
    update_interval:  60,
    track_movement:   false,
    clear_screen:     false,
    show_diff:        false,
    wait_on_change:   false,
    notify_of_change: false,
    notify_sticky:    false,
}

option_parser = OptionParser.new { |opts|
  Option::add_option(options, opts, '-a', '--adjust-scores', :adjust_scores)
  Option::add_option(options, opts, '-b', '--show-both', :show_both)
  Option::add_option(options, opts, '-u', '--update', :update)
  Option::add_option_with_param_and_type(options, opts, '-i', '--update-interval INTERVAL', :update_interval, Integer)
  Option::add_option(options, opts, '-t', '--track-movement', :track_movement)
  Option::add_option(options, opts, '-c', '--clear-screen', :clear_screen)
  Option::add_option(options, opts, '-d', '--show-diff', :show_diff)
  Option::add_option(options, opts, '-w', '--wait-on-change', :wait_on_change)
  Option::add_option(options, opts, '-n', '--notify-of-change', :notify_of_change)
  Option::add_option(options, opts, '-s', '--notify-sticky', :notify_sticky)
}

option_parser.parse!

if options[:clear_screen] && !options[:update]
  system('clear')
end

datab_only = options[:adjust_scores] && !options[:show_both]
datab_any  = options[:adjust_scores] || options[:show_both]

Signal.trap('SIGINT') {
  puts "\n\n"
  exit 1
}

def make_line(str0, str1, str0b, str2, datab_any, datab_only, data_both, joinstr = '|')
  vals = [datab_any ? str0b : str0]
  vals << str2 if datab_any
  vals << str0 if data_both
  vals << str1 unless datab_only
  "#{joinstr}#{vals.join(joinstr)}#{joinstr}"
end

def find_index(uname, data)
  data.nil? ? nil : data.find_index { |i| i[0] == uname }
end

def get_diff(v, i2, prev_data)
  i2.nil? ? nil : v[1] - prev_data[i2][1]
end

def add_diffs(data, prev_data)
  arrow_up   = Format::colorize("\u2191", :green)
  arrow_down = Format::colorize("\u2193", :red)
  new_data   = []
  data.each_with_index { |v, i|
    i2    = find_index(v[0], prev_data)
    d     = i2.nil? ? nil : i2 <=> i
    c     = d.nil? ? '?' : (d == 0 ? '-' : (d < 0 ? arrow_down : arrow_up))
    diff  = get_diff(v, i2, prev_data)
    diff2 = "(#{diff.nil? ? '?' : (diff == 0 ? diff : (diff < 0 ? Format::colorize(diff, :red) : Format::colorize(diff, :green)))})"
    new_data << [v[0], v[1], c, diff2, (diff.nil? ? 1 : diff.to_s.length) + 2]
  }
  new_data
end

def mycenter(text, len, tlen)
  b = ((len - tlen) / 2).floor
  a = len - tlen - b
  "#{' ' * b}#{text}#{' ' * a}"
end

def has_change(data, prev_data)
  if prev_data.nil?
    return false
  end
  rval = false
  data.each_with_index { |v, i|
    v2 = prev_data[i]
    rval = true if v2[0] != v[0] || v2[1] != v[1]
  }
  rval
end

def myputs(text, pad)
  myprint("#{text}\n", pad)
end

def myprint(text, pad)
  if pad.nil?
    print text
  else
    if text.include?("\e")
      pieces = text.scan(/#{"\e"}\[(\d+)m([^#{"\e"}]+?)#{"\e"}\[0m|([^#{"\e"}]+)/)
      pieces.each { |v|
        if v[2].nil?
          pad.attron(Curses::color_pair(v[0].to_s == '31' ? Curses::COLOR_RED : Curses::COLOR_GREEN) | Curses::A_NORMAL) {
            pad << v[1]
          }
        else
          pad << v[2]
        end
      }
    else
      pad << text
    end
  end
end

def myprints(headers, bodies, footers, padh, padb, padf, subpad_size, subpad_start)
  if padh.nil?
    headers.each { |v|
      puts v
    }
    bodies.each { |v|
      puts v
    }
    footers.each { |v|
      puts v
    }
    false
  else
    padh.resize(headers.count, Curses::cols)
    padb.resize(bodies.count, Curses::cols)
    padf.resize(footers.count, Curses::cols)
    padh.clear
    padb.clear
    padf.clear
    padh.setpos(0, 0)
    padb.setpos(0, 0)
    padf.setpos(0, 0)
    myprint(headers.join("\n"), padh)
    myprint(bodies.join("\n"), padb)
    line_deficit = [0, bodies.count - subpad_size].max
    myprint(footers.join("\n"), padf)
    padh.refresh(0, 0, 0, 0, headers.count - 1, Curses::cols - 1)
    padb.refresh(line_deficit, 0, subpad_start, 0, subpad_start + subpad_size - 1, Curses::cols - 1)
    padf.refresh(0, 0, subpad_start + [subpad_size, bodies.count].min, 0, subpad_start + [subpad_size, bodies.count].min + footers.count, Curses::cols - 1)
    line_deficit
  end
end

fname  = File.expand_path('~/jranka.yaml')
fnameb = File.expand_path('~/jrankb.yaml')

padh = nil
padb = nil
padf = nil

if options[:update]
  Curses::noecho
  Curses::init_screen
  padh = Curses::Pad.new(3, Curses::cols)
  padb = Curses::Pad.new(Curses::lines - 5, Curses::cols)
  padf = Curses::Pad.new(2, Curses::cols)
  padh.keypad(true)
  padh.clear
  padh.nodelay = true
  padb.keypad(true)
  padb.clear
  padb.nodelay = true
  padf.keypad(true)
  padf.clear
  padf.nodelay = true
  Curses::cbreak
  Curses::start_color
  Curses::use_default_colors
  Curses::init_pair(Curses::COLOR_RED, Curses::COLOR_RED, -1)
  Curses::init_pair(Curses::COLOR_GREEN, Curses::COLOR_GREEN, -1)
end
begin
  begin
    headers = []
    bodies  = []
    footers = []

    previous_data  = nil
    previous_datab = nil

    if options[:track_movement] || options[:show_diff]
      previous_data = YAML::load_file(fname) if File.exist?(fname)
      previous_datab = YAML::load_file(fnameb) if File.exist?(fnameb)
    end

    source = Net::HTTP.get('ci2.plab.interactions.net', '/cigame/?', 8080)

    match_str  = '>Score</td></tr><tr>'
    match_str2 = '</tr></table>'
    ind        = source.index(match_str)
    ind2       = source.index(match_str2, ind)

    str = source[(ind+match_str.length)...ind2]

    regex  = %r{</tr><tr>}
    regex2 = %r{<td><a.*?>(.*?)</a></td><td>.*?</td><td>(.*?)</td>}

    parts = str.split(regex)

    data = {}

    parts.each { |v|
      matcher = regex2.match(v)
      unless matcher.nil?
        data[matcher[1]] = matcher[2].to_f.round
      end
    }

    datab = {}

    avg = data.values.average.round
    headers << "Average: #{avg}" if datab_any
    data.keys.each { |k|
      datab[k] = data[k] - avg
    }

    data = data.sort_by { |k, v| -(v.abs) }

    datab = datab.sort_by { |k, v| -(v.abs) }

    if options[:track_movement] || options[:show_diff]
      IO::write(fname, data.to_yaml)
      IO::write(fnameb, datab.to_yaml)
    end

    data2 = add_diffs(data, previous_data)

    datab2 = add_diffs(datab, previous_datab)

    len1 = data.max { |a, b| a[0].to_s.length <=> b[0].to_s.length }

    len2 = data.max { |a, b| a[1].to_s.length <=> b[1].to_s.length }

    len1 = len1.to_s.length
    len2 = len2[1].to_s.length

    if len1 < 4
      len1 = 4
    end

    len3 = datab.max { |a, b| a[1].to_s.length <=> b[1].to_s.length }

    len3 = len3[1].to_s.length

    len4 = (data2.max { |a, b| a[4] <=> b[4] })[4] + 2

    len5 = (datab2.max { |a, b| a[4] <=> b[4] })[4] + 2

    len2b = len2
    len3b = len3

    len2b += len4 if options[:show_diff]
    len3b += len5 if options[:show_diff]

    if len2b < 5
      len2b = 5
      len2  = len2b - (options[:show_diff] ? len4 : 0)
    end

    if len3b < 14
      len3b = 14
      len3  = len3b - (options[:show_diff] ? len5 : 0)
    end

    padding = 5

    border = make_line("#{'-' * (len1+(padding*2)+(options[:track_movement] ? 1 : 0))}", "#{'-' * (len2b+(padding*2))}", "#{'-' * (len1+(padding*2)+(options[:track_movement] ? 1 : 0))}", "#{'-' * (len3b+(padding*2))}", datab_any, datab_only, options[:show_both], '+')

    user_str   = "#{' ' * padding}#{'User'.center(len1)}#{' ' * (padding+(options[:track_movement] ? 1 : 0))}"
    score_str1 = "#{' ' * padding}#{'Score'.center(len2b)}#{' ' * padding}"
    score_str2 = "#{' ' * padding}#{'Adjusted Score'.center(len3b)}#{' ' * padding}"

    headers << border
    headers << make_line(user_str, score_str1, user_str, score_str2, datab_any, datab_only, options[:show_both])
    headers << border

    (0...data2.count).each { |i|
      kv1 = data2[i]
      kv2 = datab2[i]
      ds1 = options[:show_diff] ? mycenter(kv1[3], len4, kv1[4]) : ''
      ds2 = options[:show_diff] ? mycenter(kv2[3], len5, kv2[4]) : ''
      as1 = options[:track_movement] ? kv1[2] : ''
      as2 = options[:track_movement] ? kv2[2] : ''
      bodies << make_line("#{' ' * padding}#{kv1[0].to_s.center(len1)}#{as1}#{' ' * padding}", "#{' ' * padding}#{kv1[1].to_s.center(len2)}#{ds1}#{' ' * padding}", "#{' ' * padding}#{kv2[0].to_s.center(len1)}#{as2}#{' ' * padding}", "#{' ' * padding}#{kv2[1].to_s.center(len3)}#{ds2}#{' ' * padding}", datab_any, datab_only, options[:show_both])
    }

    footers << border

    if options[:update]
      footers << ''
      max_l  = myprints(headers, bodies, footers, padh, padb, padf, Curses::lines - (datab_any ? 6 : 5), (datab_any ? 4 : 3))
      cur_l  = max_l
      time_s = Time::now
      time_e = Time::now
      ch     = padb.getch
      until (time_e - time_s) >= options[:update_interval]
        time_e = Time::now
        if ch == Curses::Key::UP
          cur_l = [0, cur_l - 1].max
        elsif ch == Curses::Key::DOWN
          cur_l = [max_l, cur_l + 1].min
        end
        if ch == Curses::Key::UP || ch == Curses::Key::DOWN
          padh.refresh(0, 0, 0, 0, (datab_any ? 3 : 2), Curses::cols - 1)
          padb.refresh(cur_l, 0, (datab_any ? 4 : 3), 0, Curses::lines - 3, Curses::cols - 1)
          padf.refresh(0, 0, (datab_any ? 4 : 3) + [Curses::lines - (datab_any ? 6 : 5), bodies.count].min, 0, (datab_any ? 4 : 3) + [Curses::lines - (datab_any ? 6 : 5), bodies.count].min + footers.count, Curses::cols - 1)
        end
        sleep(0.05)
        ch = padb.getch
      end
      if (options[:wait_on_change] || options[:notify_of_change]) && (has_change(data, previous_data) || has_change(datab, previous_datab))
        if options[:notify_of_change]
          `growlnotify -n Terminal -a Terminal#{(options[:notify_sticky] ? ' -s' : '')} -m "New Changes" -t "jrank"`
        end
        padf << 'There are changes since the last check. Press ENTER to continue...'
        padf.refresh(0, 0, (datab_any ? 4 : 3) + [Curses::lines - (datab_any ? 6 : 5), bodies.count].min, 0, (datab_any ? 4 : 3) + [Curses::lines - (datab_any ? 6 : 5), bodies.count].min + footers.count, Curses::cols - 1)
        ch     = padb.getch
        until ch == 10
          if ch == Curses::Key::UP
            cur_l = [0, cur_l - 1].max
          elsif ch == Curses::Key::DOWN
            cur_l = [max_l, cur_l + 1].min
          end
          if ch == Curses::Key::UP || ch == Curses::Key::DOWN
            padh.refresh(0, 0, 0, 0, (datab_any ? 3 : 2), Curses::cols - 1)
            padb.refresh(cur_l, 0, (datab_any ? 4 : 3), 0, Curses::lines - 3, Curses::cols - 1)
            padf.refresh(0, 0, (datab_any ? 4 : 3) + [Curses::lines - (datab_any ? 6 : 5), bodies.count].min, 0, (datab_any ? 4 : 3) + [Curses::lines - (datab_any ? 6 : 5), bodies.count].min + footers.count, Curses::cols - 1)
          end
          sleep(0.05)
          ch = padb.getch
        end
      end
    end
  end while options[:update]
ensure
  Curses::close_screen unless padh.nil?
end