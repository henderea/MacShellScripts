#!/usr/bin/env ruby

$LOAD_PATH << File.dirname(__FILE__)

require 'optparse'
require 'net/http'
require 'yaml'
require 'lib/maputil'
require 'lib/option'
require 'lib/format'

options = {
    adjust_scores:   false,
    show_both:       false,
    update:          false,
    update_interval: 60,
    track_movement:  false,
    clear_screen:    false,
    show_diff:       false,
}

option_parser = OptionParser.new { |opts|
  Option::add_option(options, opts, '-a', '--adjust-scores', :adjust_scores)
  Option::add_option(options, opts, '-b', '--show-both', :show_both)
  Option::add_option(options, opts, '-u', '--update', :update)
  Option::add_option_with_param_and_type(options, opts, '-i', '--update-interval INTERVAL', :update_interval, Integer)
  Option::add_option(options, opts, '-t', '--track-movement', :track_movement)
  Option::add_option(options, opts, '-c', '--clear-screen', :clear_screen)
  Option::add_option(options, opts, '-d', '--show-diff', :show_diff)
}

option_parser.parse!

if options[:clear_screen]
  system('clear')
end

datab_only = options[:adjust_scores] && !options[:show_both]
datab_any  = options[:adjust_scores] || options[:show_both]

Signal.trap('SIGINT') {
  puts "\n\n"
  exit 1
}

def make_line(str0, str1, str0b, str2, datab_any, datab_only, data_both, joinstr = '|')
  vals = [datab_any ? str0b : str0]
  vals << str2 if datab_any
  vals << str0 if data_both
  vals << str1 unless datab_only
  "#{joinstr}#{vals.join(joinstr)}#{joinstr}"
end

def find_index(uname, data)
  data.nil? ? nil : data.find_index { |i| i[0] == uname }
end

def get_diff(v, i2, prev_data)
  i2.nil? ? nil : v[1] - prev_data[i2][1]
end

def add_diffs(data, prev_data)
  arrow_up   = Format::colorize("\u2191", :green)
  arrow_down = Format::colorize("\u2193", :red)
  new_data   = []
  data.each_with_index { |v, i|
    i2    = find_index(v[0], prev_data)
    d     = i2.nil? ? nil : i2 <=> i
    c     = d.nil? ? '?' : (d == 0 ? '-' : (d < 0 ? arrow_down : arrow_up))
    diff  = get_diff(v, i2, prev_data)
    diff2 = " (#{diff.nil? ? '?' : (diff == 0 ? diff : (diff < 0 ? Format::colorize(diff, :red) : Format::colorize(diff, :green)))})"
    new_data << [v[0], v[1], c, diff2, (diff.nil? ? 1 : diff.to_s.length) + 3]
  }
  new_data
end

def mycenter(text, len, tlen)
  b = ((len - tlen) / 2).floor
  a = len - tlen - b
  "#{' ' * b}#{text}#{' ' * a}"
end

fname  = File.expand_path('~/jranka.yaml')
fnameb = File.expand_path('~/jrankb.yaml')

begin
  previous_data  = nil
  previous_datab = nil

  if options[:track_movement] || options[:show_diff]
    previous_data = YAML::load_file(fname) if File.exist?(fname)
    previous_datab = YAML::load_file(fnameb) if File.exist?(fnameb)
  end

  source = Net::HTTP.get('ci2.plab.interactions.net', '/cigame/?', 8080)

  match_str  = '>Score</td></tr><tr>'
  match_str2 = '</tr></table>'
  ind        = source.index(match_str)
  ind2       = source.index(match_str2, ind)

  str = source[(ind+match_str.length)...ind2]

  regex  = %r{</tr><tr>}
  regex2 = %r{<td><a.*?>(.*?)</a></td><td>.*?</td><td>(.*?)</td>}

  parts = str.split(regex)

  data = {}

  parts.each { |v|
    matcher = regex2.match(v)
    unless matcher.nil?
      data[matcher[1]] = matcher[2].to_f.round
    end
  }

  datab = {}

  avg = data.values.average.round
  puts "Average: #{avg}" if datab_any
  data.keys.each { |k|
    datab[k] = data[k] - avg
  }

  data = data.sort_by { |k, v| -(v.abs) }

  datab = datab.sort_by { |k, v| -(v.abs) }

  if options[:track_movement] || options[:show_diff]
    IO::write(fname, data.to_yaml)
    IO::write(fnameb, datab.to_yaml)
  end

  data2 = add_diffs(data, previous_data)

  datab2 = add_diffs(datab, previous_datab)

  len1 = data.max { |a, b| a[0].to_s.length <=> b[0].to_s.length }

  len2 = data.max { |a, b| a[1].to_s.length <=> b[1].to_s.length }

  len1 = len1.to_s.length
  len2 = len2.to_s.length

  if len1 < 4
    len1 = 4
  end

  if len2 < 5
    len2 = 5
  end

  len3 = datab.max { |a, b| a[1].to_s.length <=> b[1].to_s.length }

  len3 = len3.to_s.length

  if len3 < 14
    len3 = 14
  end

  len4 = (data2.max { |a, b| a[4] <=> b[4] })[4]

  len5 = (datab2.max { |a, b| a[4] <=> b[4] })[4]

  len2 += len4 if options[:show_diff]
  len3 += len5 if options[:show_diff]

  padding = 5

  border = make_line("#{'-' * (len1+(padding*2)+(options[:track_movement] ? 1 : 0))}", "#{'-' * (len2+(padding*2))}", "#{'-' * (len1+(padding*2)+(options[:track_movement] ? 1 : 0))}", "#{'-' * (len3+(padding*2))}", datab_any, datab_only, options[:show_both], '+')

  user_str   = "#{' ' * padding}#{'User'.center(len1)}#{' ' * (padding+(options[:track_movement] ? 1 : 0))}"
  score_str1 = "#{' ' * padding}#{'Score'.center(len2)}#{' ' * padding}"
  score_str2 = "#{' ' * padding}#{'Adjusted Score'.center(len3)}#{' ' * padding}"

  puts border
  puts make_line(user_str, score_str1, user_str, score_str2, datab_any, datab_only, options[:show_both])
  puts border

  (0...data2.count).each { |i|
    kv1 = data2[i]
    kv2 = datab2[i]
    ds1 = options[:show_diff] ? kv1[3] : ''
    ds2 = options[:show_diff] ? kv2[3] : ''
    sl1 = kv1[1].to_s.length + (options[:show_diff] ? kv1[4] : 0)
    sl2 = kv2[1].to_s.length + (options[:show_diff] ? kv2[4] : 0)
    as1 = options[:track_movement] ? kv1[2] : ''
    as2 = options[:track_movement] ? kv2[2] : ''
    puts make_line("#{' ' * padding}#{kv1[0].to_s.center(len1)}#{as1}#{' ' * padding}", "#{' ' * padding}#{mycenter("#{kv1[1]}#{ds1}", len2, sl1)}#{' ' * padding}", "#{' ' * padding}#{kv2[0].to_s.center(len1)}#{as2}#{' ' * padding}", "#{' ' * padding}#{mycenter("#{kv2[1]}#{ds2}", len3, sl2)}#{' ' * padding}", datab_any, datab_only, options[:show_both])
  }

  puts border

  if options[:update]
    sleep(options[:update_interval])
    print "\r\e[#{data.count + (datab_any ? 5 : 4)}A\e[J"
  end
end while options[:update]