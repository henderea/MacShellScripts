#!/usr/bin/env ruby

$LOAD_PATH << File.dirname(__FILE__)

require 'optparse'
require 'net/http'
require 'yaml'
require 'lib/maputil'
require 'lib/option'
require 'lib/format'
require 'lib/mycurses'

options = {
    adjust_scores:    false,
    show_both:        false,
    update:           false,
    update_interval:  60,
    track_movement:   false,
    clear_screen:     false,
    show_diff:        false,
    wait_on_change:   false,
    notify_of_change: false,
    notify_sticky:    false,
}

option_parser = OptionParser.new { |opts|
  Option::add_option(options, opts, '-a', '--adjust-scores', :adjust_scores)
  Option::add_option(options, opts, '-b', '--show-both', :show_both)
  Option::add_option(options, opts, '-u', '--update', :update)
  Option::add_option_with_param_and_type(options, opts, '-i', '--update-interval INTERVAL', :update_interval, Integer)
  Option::add_option(options, opts, '-t', '--track-movement', :track_movement)
  Option::add_option(options, opts, '-c', '--clear-screen', :clear_screen)
  Option::add_option(options, opts, '-d', '--show-diff', :show_diff)
  Option::add_option(options, opts, '-w', '--wait-on-change', :wait_on_change)
  Option::add_option(options, opts, '-n', '--notify-of-change', :notify_of_change)
  Option::add_option(options, opts, '-s', '--notify-sticky', :notify_sticky)
}

option_parser.parse!

if options[:clear_screen] && !options[:update]
  system('clear')
end

datab_only = options[:adjust_scores] && !options[:show_both]
datab_any  = options[:adjust_scores] || options[:show_both]

Signal.trap('SIGINT') {
  puts "\n\n"
  exit 1
}

def make_line(str0, str1, str0b, str2, datab_any, datab_only, data_both, joinstr = '|')
  vals = [datab_any ? str0b : str0]
  vals << str2 if datab_any
  vals << str0 if data_both
  vals << str1 unless datab_only
  "#{joinstr}#{vals.join(joinstr)}#{joinstr}"
end

def find_index(uname, data)
  data.nil? ? nil : data.find_index { |i| i[0] == uname }
end

def get_diff(v, i2, prev_data)
  i2.nil? ? nil : v[1] - prev_data[i2][1]
end

def add_diffs(data, prev_data)
  arrow_up   = Format::colorize("\u2191", :green)
  arrow_down = Format::colorize("\u2193", :red)
  new_data   = []
  data.each_with_index { |v, i|
    i2    = find_index(v[0], prev_data)
    d     = i2.nil? ? nil : i2 <=> i
    c     = d.nil? ? '?' : (d == 0 ? '-' : (d < 0 ? arrow_down : arrow_up))
    diff  = get_diff(v, i2, prev_data)
    diff2 = "(#{diff.nil? ? '?' : (diff == 0 ? diff : (diff < 0 ? Format::colorize(diff, :red) : Format::colorize(diff, :green)))})"
    new_data << [v[0], v[1], c, diff2, (diff.nil? ? 1 : diff.to_s.length) + 2]
  }
  new_data
end

def mycenter(text, len, tlen)
  b = ((len - tlen) / 2).floor
  a = len - tlen - b
  "#{' ' * b}#{text}#{' ' * a}"
end

def has_change(data, prev_data)
  if prev_data.nil?
    return false
  end
  rval = false
  data.each_with_index { |v, i|
    v2 = prev_data[i]
    rval = true if v2[0] != v[0] || v2[1] != v[1]
  }
  rval
end

fname  = File.expand_path('~/jranka.yaml')
fnameb = File.expand_path('~/jrankb.yaml')

mycurses = MyCurses.new(options[:update], (datab_any ? 4 : 3), 2)

net              = Net::HTTP.new('ci2.plab.interactions.net', 8080)
net.read_timeout = 5

def read_previous_data(options, fname, fnameb)
  previous_data  = nil
  previous_datab = nil

  if options[:track_movement] || options[:show_diff]
    previous_data = YAML::load_file(fname) if File.exist?(fname)
    previous_datab = YAML::load_file(fnameb) if File.exist?(fnameb)
  end
  return previous_data, previous_datab
end

def read_source(net)
  source = nil

  while source.nil?
    begin
      response = net.get('/cigame/?')
      if response.kind_of?(Net::HTTPSuccess)
        source = response.body
      else
        source = nil
      end
    rescue
      # ignored
    end
  end
  source
end

def get_data(net, mycurses, datab_any)
  source = read_source(net)

  match_str  = '>Score</td></tr><tr>'
  match_str2 = '</tr></table>'
  ind        = source.index(match_str)
  ind2       = source.index(match_str2, ind)

  str = source[(ind+match_str.length)...ind2]

  regex  = %r{</tr><tr>}
  regex2 = %r{<td><a.*?>(.*?)</a></td><td>.*?</td><td>(.*?)</td>}

  parts = str.split(regex)

  data = {}

  parts.each { |v|
    matcher = regex2.match(v)
    unless matcher.nil?
      data[matcher[1]] = matcher[2].to_f.round
    end
  }

  datab = {}

  avg = data.values.average.round
  mycurses.headers << "Average: #{avg}" if datab_any
  data.keys.each { |k|
    datab[k] = data[k] - avg
  }
  data  = data.sort_by { |k, v| -(v.abs) }
  datab = datab.sort_by { |k, v| -(v.abs) }
  return data, datab
end

def write_data(data, datab, fname, fnameb, options)
  if options[:track_movement] || options[:show_diff]
    IO::write(fname, data.to_yaml)
    IO::write(fnameb, datab.to_yaml)
  end
end

def extend_data(data, datab, previous_data, previous_datab)
  data2  = add_diffs(data, previous_data)
  datab2 = add_diffs(datab, previous_datab)
  return data2, datab2
end

def lengths(options, data2, datab2)
  len1 = data2.max { |a, b| a[0].to_s.length <=> b[0].to_s.length }
  len2 = data2.max { |a, b| a[1].to_s.length <=> b[1].to_s.length }
  len1 = len1[0].to_s.length
  len2 = len2[1].to_s.length

  if len1 < 4
    len1 = 4
  end

  len3 = datab2.max { |a, b| a[1].to_s.length <=> b[1].to_s.length }
  len3 = len3[1].to_s.length

  len4 = (data2.max { |a, b| a[4] <=> b[4] })[4] + 2
  len5 = (datab2.max { |a, b| a[4] <=> b[4] })[4] + 2

  len2b = len2
  len3b = len3

  len2b += len4 if options[:show_diff]
  len3b += len5 if options[:show_diff]

  if len2b < 5
    len2b = 5
    len2  = len2b - (options[:show_diff] ? len4 : 0)
  end

  if len3b < 14
    len3b = 14
    len3  = len3b - (options[:show_diff] ? len5 : 0)
  end
  return len1, len2, len2b, len3, len3b, len4, len5
end

def add_headers(options, mycurses, border, datab_any, datab_only, len1, len2b, len3b, padding)
  user_str   = "#{' ' * padding}#{'User'.center(len1)}#{' ' * (padding+(options[:track_movement] ? 2 : 0))}"
  score_str1 = "#{' ' * padding}#{'Score'.center(len2b)}#{' ' * padding}"
  score_str2 = "#{' ' * padding}#{'Adjusted Score'.center(len3b)}#{' ' * padding}"

  mycurses.headers << border
  mycurses.headers << make_line(user_str, score_str1, user_str, score_str2, datab_any, datab_only, options[:show_both])
  mycurses.headers << border
end

def add_bodies(options, mycurses, data2, datab2, datab_any, datab_only, len1, len2, len3, len4, len5, padding)
  (0...data2.count).each { |i|
    kv1 = data2[i]
    kv2 = datab2[i]
    ds1 = options[:show_diff] ? mycenter(kv1[3], len4, kv1[4]) : ''
    ds2 = options[:show_diff] ? mycenter(kv2[3], len5, kv2[4]) : ''
    as1 = options[:track_movement] ? " #{kv1[2]}" : ''
    as2 = options[:track_movement] ? " #{kv2[2]}" : ''
    mycurses.bodies << make_line("#{' ' * padding}#{kv1[0].to_s.center(len1)}#{as1}#{' ' * padding}", "#{' ' * padding}#{kv1[1].to_s.center(len2)}#{ds1}#{' ' * padding}", "#{' ' * padding}#{kv2[0].to_s.center(len1)}#{as2}#{' ' * padding}", "#{' ' * padding}#{kv2[1].to_s.center(len3)}#{ds2}#{' ' * padding}", datab_any, datab_only, options[:show_both])
  }
end

def add_footers(options, mycurses, border)
  mycurses.footers << border
  mycurses.footers << '' if options[:update]
end

begin
  begin
    mycurses.clear

    previous_data, previous_datab              = read_previous_data(options, fname, fnameb)
    data, datab                                = get_data(net, mycurses, datab_any)
    data2, datab2                              = extend_data(data, datab, previous_data, previous_datab)
    len1, len2, len2b, len3, len3b, len4, len5 = lengths(options, data2, datab2)
    padding                                    = 5

    border = make_line("#{'-' * (len1+(padding*2)+(options[:track_movement] ? 2 : 0))}", "#{'-' * (len2b+(padding*2))}", "#{'-' * (len1+(padding*2)+(options[:track_movement] ? 2 : 0))}", "#{'-' * (len3b+(padding*2))}", datab_any, datab_only, options[:show_both], '+')

    add_headers(options, mycurses, border, datab_any, datab_only, len1, len2b, len3b, padding)
    add_bodies(options, mycurses, data2, datab2, datab_any, datab_only, len1, len2, len3, len4, len5, padding)
    add_footers(options, mycurses, border)
    mycurses.myprints

    if options[:update]
      write_data(data, datab, fname, fnameb, options)
      time_s = Time::now
      time_e = Time::now
      mycurses.clear_ch
      until (time_e - time_s) >= options[:update_interval] || mycurses.ch == 10
        time_e = Time::now
        mycurses.scroll_iteration
      end
      if mycurses.ch != 10 && (options[:wait_on_change] || options[:notify_of_change]) && (has_change(data, previous_data) || has_change(datab, previous_datab))
        if options[:notify_of_change]
          `growlnotify -n Terminal -a Terminal#{(options[:notify_sticky] ? ' -s' : '')} -m "New Changes" -t "jrank"`
        end
        mycurses.footer_live_append('There are changes since the last check. Press ENTER to continue...')
        mycurses.clear_ch
        until mycurses.ch == 10
          mycurses.scroll_iteration
        end
      end
    end
  end while options[:update]
ensure
  mycurses.dispose
end