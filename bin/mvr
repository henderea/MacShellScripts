#!/usr/bin/env ruby

$LOAD_PATH << File.dirname(__FILE__)

require 'lib/format'

include Format

pattern = ARGV.shift
if pattern == 'help' || pattern == '--help' || pattern == '-h'
  puts bold('NAME')
  puts "    #{bold('mvr', :purple)} -- Renames a group of files and/or folders using a regular expression\n\n"
  puts bold('SYNOPSIS')
  puts "    #{bold('mvr', :purple)} <#{underline('find', :cyan)}> <#{underline('replace', :cyan)}> #{colorize('file ...', :cyan)}\n\n"
  puts bold('DESCRIPTION')
  puts "    #{bold('mvr', :purple)} is a Ruby script that allows you to rename a group of files and/or folders using a regular expression."
  puts "    The #{underline('find', :cyan)} parameter uses normal regular expression syntax (there might be Ruby-specific things, but I doubt it)."
  puts "    The #{underline('replace', :cyan)} parameter is plain text, using #{colorize('\\#', :green)} to insert capture group #{colorize('#', :green)} (so #{colorize('\\1', :green)} to insert the first capture group)."
  puts '    The list of files can be as many items as you want, and you can use typical wildcard expressions.'
  puts "    Any parameter after #{underline('replace', :cyan)} will be interpreted as a file/folder name that should be included in the list of what to rename.\n\n"
  puts '    Parameters:'
  puts "    <#{underline('find', :cyan)}>     The regular expression for the renaming"
  puts "    <#{underline('replace', :cyan)}>  The text to replace what the regular expression matches (use #{colorize('\\#', :green)} to insert capture group #{colorize('#', :green)} (so #{colorize('\\1', :green)} to insert the first capture group))"
  puts "    #{colorize('file ...', :cyan)}   The list of files and/or folders to rename"
  exit
end
if ARGV.length < 2
  puts "\n#{boldunderline('Usage')}: #{bold('mvr', :purple)} <#{underline('find', :cyan)}> <#{underline('replace', :cyan)}> #{colorize('file ...', :cyan)}\n\n"
  puts "Run #{bold('mvr', :purple)} #{bold('help', :cyan)} for command information.  There is also a man page that should be accessible via #{bold('man', :purple)} #{bold('mvr', :cyan)}\n\n"
  exit
end
replacement = ARGV.shift
regex       = /#{pattern}/o
mappings    = Hash.new
encountered = Array.new
duplicated  = Array.new
ARGV.each do |filename|
  file_basename        = File.basename(filename)
  directory            = filename[0, (filename.length - file_basename.length)]
  replacement_basename = file_basename.gsub(regex, replacement)
  replacement_name     = "#{directory}#{replacement_basename}"
  mappings[filename]   = replacement_name
  if encountered.include?(replacement_name)
    unless duplicated.include?(replacement_name)
      duplicated << replacement_name
    end
  else
    encountered << replacement_name
  end
end

ARGV.clear

len1 = mappings.keys.max do |a, b|
  a.length <=> b.length
end

len2 = mappings.values.max do |a, b|
  a.length <=> b.length
end

len1 = len1.length
len2 = len2.length

if len1 < 3
  len1 = 3
end

if len2 < 3
  len2 = 3
end

border = "+#{'-' * (len1+2)}+#{'-' * (len2+2)}+"

puts border
puts "| #{'Old'.center(len1)} | #{'New'.center(len2)} |"
puts border

mappings.each do |from, to|
  from2 = from.center(len1)
  to2 = to.center(len2)
  if from == to
    from2 = colorize(from2, :black, :white)
    to2 = colorize(to2, :black, :white)
  elsif duplicated.include?(to)
    from2 = colorize(from2, :white, :red)
    to2 = colorize(to2, :white, :red)
  end
  puts "| #{from2} | #{to2} |"
end

puts border

print "\nAre you sure you want to rename these files (yes/no or y/n)? "
response = gets.chomp
if response.downcase == 'yes' || response.downcase == 'y'
  mappings.each do |from, to|
    if from != to
      File.rename(from, to)
    end
  end
end
